"""autogenerated by genpy from ackermann_msgs/AckermannDriveStamped.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import ackermann_msgs.msg
import std_msgs.msg

class AckermannDriveStamped(genpy.Message):
    _md5sum = "1fd5d7f58889cefd44d29f6653240d0c"
    _type = "ackermann_msgs/AckermannDriveStamped"
    _has_header = True #flag to mark the presence of a Header object
    # _full_text = """## Time stamped drive command for robots with Ackermann steering.

    __slots__ = ['header','drive']
    _slot_types = ['std_msgs/Header','ackermann_msgs/AckermannDrive']

    def __init__(self, *args, **kwds):
        if args or kwds:
            super(AckermannDriveStamped, self).__init__(*args, **kwds)
            #message fields cannot be None, assign default values for those that are
            if self.header is None:
                self.header = std_msgs.msg.Header()
            if self.drive is None:
                self.drive = ackermann_msgs.msg.AckermannDrive()
        else:
            self.header = std_msgs.msg.Header()
            self.drive = ackermann_msgs.msg.AckermannDrive()

    def _get_types(self):
        return self._slot_types

    def serialize(self, buff):
        try:
            _x = self
            buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
            _x = self.header.frame_id
            length = len(_x)
            if python3 or type(_x) == unicode:
                _x = _x.encode('utf-8')
                length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = self
            buff.write(_struct_5f.pack(_x.drive.steering_angle, _x.drive.steering_angle_velocity, _x.drive.speed, _x.drive.acceleration, _x.drive.jerk))
        except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
        except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

    def deserialize(self, str):
        try:
            if self.header is None:
                self.header = std_msgs.msg.Header()
            if self.drive is None:
                self.drive = ackermann_msgs.msg.AckermannDrive()
            end = 0
            _x = self
            start = end
            end += 12
            (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
                self.header.frame_id = str[start:end].decode('utf-8')
            else:
                self.header.frame_id = str[start:end]
            _x = self
            start = end
            end += 20
            (_x.drive.steering_angle, _x.drive.steering_angle_velocity, _x.drive.speed, _x.drive.acceleration, _x.drive.jerk,) = _struct_5f.unpack(str[start:end])
            return self
        except struct.error as e:
            raise genpy.DeserializationError(e) #most likely buffer underfill

    def serialize_numpy(self, buff, numpy):
        try:
            _x = self
            buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
            _x = self.header.frame_id
            length = len(_x)
            if python3 or type(_x) == unicode:
                _x = _x.encode('utf-8')
                length = len(_x)
            buff.write(struct.pack('<I%ss'%length, length, _x))
            _x = self
            buff.write(_struct_5f.pack(_x.drive.steering_angle, _x.drive.steering_angle_velocity, _x.drive.speed, _x.drive.acceleration, _x.drive.jerk))
        except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
        except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

    def deserialize_numpy(self, str, numpy):
        try:
            if self.header is None:
                self.header = std_msgs.msg.Header()
            if self.drive is None:
                self.drive = ackermann_msgs.msg.AckermannDrive()
            end = 0
            _x = self
            start = end
            end += 12
            (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
                self.header.frame_id = str[start:end].decode('utf-8')
            else:
                self.header.frame_id = str[start:end]
            _x = self
            start = end
            end += 20
            (_x.drive.steering_angle, _x.drive.steering_angle_velocity, _x.drive.speed, _x.drive.acceleration, _x.drive.jerk,) = _struct_5f.unpack(str[start:end])
            return self
        except struct.error as e:
            raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_3I = struct.Struct("<3I")
_struct_5f = struct.Struct("<5f")
